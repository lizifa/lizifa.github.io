System.register(["./common-legacy-c76da15f.js","./index-legacy-2f5c4832.js"],(function(n,e){"use strict";var o;return{setters:[n=>{o=n.c},null],execute:function(){const e="<h1>前端需要去了解的 nodejs 知识</h1>\n<h2>node 是什么？</h2>\n<ul>\n<li>Node.js 是一个基于&quot;Chrome V8 引擎&quot;的 JavaScript&quot;运行环境&quot;。</li>\n</ul>\n<h2>什么是 V8 引擎？</h2>\n<ul>\n<li>V8 引擎是一款专门解释和执行 JavaScript 代码的虚拟机。任何程序只要集成了 V8 引擎，就可以执行 JavaScript 代码。</li>\n<li>浏览器集成了 V8 引擎，可以执行 JavaScript 代码；</li>\n<li>将 V8 引擎嵌入到 NodeJS 中，那么我们写的 JavaScript 代码就会被 NodeJS 所执行。</li>\n</ul>\n<h2>什么是运行环境？</h2>\n<ul>\n<li>运行环境是指支持特定软件或应用程序运行的环境，包括硬件和软件环境。</li>\n<li>在软件领域中，运行环境通常包括操作系统、运行时库、编程语言解释器、库文件和其他必要的组件。</li>\n<li>这些组件都需要与软件应用程序进行交互，以便程序能够在特定环境下运行。</li>\n<li>通常，开发者需要为不同的运行环境编写代码以确保软件在不同操作系统、不同设备上具有兼容性。</li>\n</ul>\n<h2>node 能做什么</h2>\n<ul>\n<li>写 web 服务器后台（java，php 能做的，node 也能做）</li>\n<li>做项目构建工具，例如 webpack、vue-cli 都是用 node 写的</li>\n<li>做命令行工具，例如 hexo（一款快速、简洁且高效的博客框架）就是用 node 写的</li>\n<li>用于桌面开发</li>\n</ul>\n<h2>demo</h2>\n<pre><code>const http = require('http');\n\nconst hostname = '127.0.0.1';\nconst port = 3000;\n\nconst server = http.createServer((req, res) =&gt; {\n  res.statusCode = 200;\n  res.setHeader('Content-Type', 'text/plain');\n  res.end('Hello World');\n});\n\nserver.listen(port, hostname, () =&gt; {\n  console.log(`Server running at http://${hostname}:${port}/`);\n});\n</code></pre>\n",t=(n("__default",o("intro","简介","/notes/nodejs/intro",e)),n("tinypng",o("tinypng","图片压缩","/notes/nodejs/tinypng","<h1>使用 node 开发图片压缩工具</h1>\n<h2>知识储备</h2>\n<ul>\n<li>了解 TinyPNG 的作用</li>\n<li>掌握基本的 nodejs</li>\n<li>了解 node 的一些第三方库</li>\n</ul>\n<h2>工程搭建</h2>\n<pre><code>1. mkdir tinypng // 创建文件目录\n2. cd tinypng // 进入新创建的目录\n3. npm init -y // npm 初始化目录\n4. npm i commander --save // 安装依赖\n5. mkdir command // 创建源码文件夹\n6. cd command // 进入源码文件夹\n7. echo #!/usr/bin/env node &gt; tinypng.js // 在该文件夹中创建一个JavaScriptw文件\n</code></pre>\n<p>然后再编辑器中打开<code>tinypng.js</code>和<code>package.json</code>文件</p>\n<p>修改 package.json 文件，修改 script 文件</p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;node command/tinypng.js&quot;\n},\n</code></pre>\n<p>开始编辑<code>tinypng.js</code>文件</p>\n<pre><code>#!/usr/bin/env node\n/**\n * 帮助文档\n * -------\n *\n * 获取帮助\n * 指令 -h\n *\n * 获取命令执行文件夹\n * 指令 -f\n * 参数 ./\n * 必填，待处理的图片文件夹\n *\n * 获取是否深度递归处理图片文件夹\n * 指令 --deep\n * 可选，默认不深度递归\n *\n *  */\n\nconst fs = require('fs');\nconst path = require('path');\nconst https = require('https');\nconst URL = require('url').URL;\nconst EventEmitter = require('events');\nconst err = msg =&gt; new EventEmitter().emit('error', msg);\n\n(() =&gt; {\n\n    if (getHelp()) {\n        return false;\n    }\n\n    const config = {\n        files: [],\n        EntryFolder: getEntryFolder(),\n        DeepLoop: getDeepLoop(),\n        Exts: ['.jpg', '.png'],\n        Max: 5200000, // 5MB == 5242848.754299136\n    }\n\n    fileFilter(config.EntryFolder)\n\n    console.log(&quot;本次执行脚本的配置：&quot;, config);\n    console.log(&quot;需要处理文件的数量:&quot;, config.files.length)\n\n    config.files.forEach(img =&gt; fileUpload(img));\n\n    //////////////////////////////// 工具函数\n\n    /**\n     * 获取帮助命令\n     * 指令 -h\n     */\n    function getHelp() {\n        let i = process.argv.findIndex(i =&gt; i === &quot;-h&quot;);\n        if (i !== -1) {\n            console.log(\n                `\n            * 帮助文档\n            * -------\n            *\n            * 获取帮助\n            * 指令 -h\n            *\n            * 获取命令执行文件夹\n            * 指令 -f\n            * 参数 ./\n            * 必填，待处理的图片文件夹\n            *\n            * 获取是否深度递归处理图片文件夹\n            * 指令 --deep\n            * 可选，默认不深度递归\n            *\n            * &gt; node ./tinypng.js -f dir --deep\n            *\n            *\n        `\n            )\n            return true;\n        }\n    }\n\n    /**\n     * 获取命令执行文件夹\n     * 指令 -f\n     * 参数 ./\n     * 必填，待处理的图片文件夹\n     */\n    function getEntryFolder() {\n        let i = process.argv.findIndex(i =&gt; i === &quot;-f&quot;);\n        if (i === -1 || !process.argv[i + 1]) return err('获取命令执行文件夹：失败');\n        return process.argv[i + 1];\n    }\n\n    /**\n     * 获取是否深度递归处理图片文件夹\n     * 指令 --deep\n     * 可选，默认不深度递归\n     */\n    function getDeepLoop() {\n        return process.argv.findIndex(i =&gt; i === &quot;--deep&quot;) !== -1;\n    }\n\n    /**\n     * 过滤待处理文件夹，得到待处理文件列表\n     * @param {*} folder 待处理文件夹\n     * @param {*} files 待处理文件列表\n     */\n    function fileFilter(folder) {\n        // 读取文件夹\n        fs.readdirSync(folder).forEach(file =&gt; {\n            let fullFilePath = path.join(folder, file)\n            // 读取文件信息\n            let fileStat = fs.statSync(fullFilePath);\n            // 过滤文件安全性/大小限制/后缀名\n            if (fileStat.size &lt;= config.Max &amp;&amp; fileStat.isFile() &amp;&amp; config.Exts.includes(path.extname(file))) config.files.push(fullFilePath);\n            // 是都要深度递归处理文件夹\n            else if (config.DeepLoop &amp;&amp; fileStat.isDirectory()) fileFilter(fullFilePath);\n        });\n    }\n\n    /**\n     * TinyPng 远程压缩 HTTPS 请求的配置生成方法\n     */\n\n    function getAjaxOptions() {\n        return {\n            method: 'POST',\n            hostname: [&quot;tinyjpg.com&quot;, &quot;tinypng.com&quot;][Math.random() &gt;= 0.5 ? 0 : 1], // 随机请求\n            path: &quot;/backend/opt/shrink&quot;,\n            headers: {\n                rejectUnauthorized: false,\n                &quot;X-Forwarded-For&quot;: Array(4).fill(1).map(() =&gt; parseInt(Math.random() * 254 + 1)).join('.'),\n                'Postman-Token': Date.now(),\n                'Cache-Control': 'no-cache',\n                'Content-Type': 'application/x-www-form-urlencoded',\n                'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'\n            }\n        }\n    }\n\n    /**\n     * TinyPng 远程压缩 HTTPS 请求\n     * @param {string} img 待处理的文件\n     * @success {\n     *              &quot;input&quot;: { &quot;size&quot;: 887, &quot;type&quot;: &quot;image/png&quot; },\n     *              &quot;output&quot;: { &quot;size&quot;: 785, &quot;type&quot;: &quot;image/png&quot;, &quot;width&quot;: 81, &quot;height&quot;: 81, &quot;ratio&quot;: 0.885, &quot;url&quot;: &quot;https://tinypng.com/web/output/7aztz90nq5p9545zch8gjzqg5ubdatd6&quot; }\n     *           }\n     * @error  {&quot;error&quot;: &quot;Bad request&quot;, &quot;message&quot; : &quot;Request is invalid&quot;}\n     */\n    function fileUpload(imgPath) {\n        let req = https.request(getAjaxOptions(), (res) =&gt; {\n            res.on('data', buf =&gt; {\n                let obj = JSON.parse(buf.toString());\n                if (obj.error) console.log(`压缩失败！\\n 当前文件：${imgPath} \\n ${obj.message}`);\n                else fileUpdate(imgPath, obj);\n            });\n        });\n\n        req.write(fs.readFileSync(imgPath), 'binary');\n        req.on('error', e =&gt; console.error(`请求错误! \\n 当前文件：${imgPath} \\n`, e));\n        req.end();\n    }\n\n    // 该方法被循环调用,请求图片数据\n    function fileUpdate(entryImgPath, obj) {\n        let options = new URL(obj.output.url);\n        let req = https.request(options, res =&gt; {\n            let body = '';\n            res.setEncoding('binary');\n            res.on('data', (data) =&gt; body += data);\n            res.on('end', () =&gt; {\n                fs.writeFile(entryImgPath, body, 'binary', err =&gt; {\n                    if (err) return console.error(err);\n                    let log = '压缩成功';\n                    log += `优化比例: ${((1 - obj.output.ratio) * 100).toFixed(2)}%`;\n                    log += `原始大小: ${(obj.input.size / 1024).toFixed(2)} KB`;\n                    log += `压缩大小: ${(obj.output.size / 1024).toFixed(2)} KB`;\n                    log += `文件：${entryImgPath}`\n                    console.log(log);\n                });\n            });\n        });\n        req.on('error', e =&gt; console.error(e));\n        req.end();\n    }\n\n})()\n\n</code></pre>\n<p>修改<code>package.json</code>文件</p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;tinypng&quot;: &quot;node command/tinypng.js -f&quot;,\n  },\n</code></pre>\n<p>我们可以在 cmd 中指定一个文件去压缩图片</p>\n<pre><code>npm run tinypng imgDir\n</code></pre>\n<p>但是，如果这是作为一个 node 包的形式，我们不希望将源码暴露，这个时候我们就需要将源代码进行压缩，\n可以通过一些 npm 提供的功能，例如<code>uglify-js</code>可以将源代码进行压缩，首先安装这个包</p>\n<pre><code>npm i uglify-js --save-dev\n</code></pre>\n<p>然后修改<code>package.json</code>文件</p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;tinypng&quot;: &quot;node command/tinypng.js -f&quot;,\n    &quot;build:tinypng&quot;: &quot;uglifyjs command/tinypng.js -o index.js -c -m&quot;\n  },\n</code></pre>\n<p>我们需要打包，将源码进行压缩，并输出到程序的根目录，并且命名为 index.js</p>\n<pre><code>npm run build:tinypng\n</code></pre>\n<p>此时，压缩的命令就可以修改成偶们打包后的文件了</p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;tinypng&quot;: &quot;node index.js -f&quot;,\n    &quot;build:tinypng&quot;: &quot;uglifyjs command/tinypng.js -o index.js -c -m&quot;\n  },\n</code></pre>\n<p>然后压缩的命令还是跟之前一样使用</p>\n<pre><code>npm run tinypng imgDir\n</code></pre>\n<p>至此，一个简单的图片压缩工具完成了</p>\n"))),r=n("nodeUpdate",o("nodeUpdate","升级node业务代码","/notes/nodejs/nodeUpdate","<h1>node 业务代码平滑更新</h1>\n<h2>负载均衡</h2>\n<p>如果要更新 a 进程，但是用户正在使用 a 进程，则需要先将用户请求从 a 进程中移除，确保用户不会受到影响。</p>\n<p>一种方法是，在更新 a 进程之前，将 a 进程从 Nginx 负载均衡的后端服务器列表中移除，在更新完成后再将其添加回去。</p>\n<p>具体的配置方法取决于你使用的 Nginx 版本和负载均衡方式。以下是一个可能的 Nginx 配置示例，假设你使用的是 upstream 模块实现负载均衡：</p>\n<pre><code>http {\n    upstream app_servers {\n        server 127.0.0.1:3000;  # a进程\n        server 127.0.0.1:3001;  # b进程\n        server 127.0.0.1:3002;  # c进程\n    }\n\n    server {\n        listen 80;\n        server_name example.com;\n\n        location / {\n            proxy_pass http://app_servers;\n        }\n    }\n}\n</code></pre>\n<p>在这个例子中，Nginx 将用户请求通过 HTTP 代理转发到 app_servers 上的某个服务器进程。如果要更新 a 进程，可以将其从 upstream 列表中移除，等更新完成后再添加回去。例如：</p>\n<pre><code>http {\n    upstream app_servers {\n        server 127.0.0.1:3001;  # b进程\n        server 127.0.0.1:3002;  # c进程\n    }\n\n    server {\n        listen 80;\n        server_name example.com;\n\n        location / {\n            proxy_pass http://app_servers;\n        }\n    }\n}\n</code></pre>\n<p>这样，在更新 a 进程时，用户的请求就不会被转发到 a 进程上，而是被转发到其他正常运行的进程上，确保用户不会受到影响。</p>\n<p>更新完成后，记得将 a 进程重新添加到 upstream 列表中，例如：</p>\n<pre><code>http {\n    upstream app_servers {\n        server 127.0.0.1:3000;  # a进程\n        server 127.0.0.1:3001;  # b进程\n        server 127.0.0.1:3002;  # c进程\n    }\n\n    server {\n        listen 80;\n        server_name example.com;\n\n        location / {\n            proxy_pass http://app_servers;\n        }\n    }\n}\n</code></pre>\n<p>这样，Nginx 就会将用户请求平均分配到所有正常运行的进程中，确保服务的稳定性和可用性。</p>\n<h2>平滑重启</h2>\n<ul>\n<li>那么 a 进程如何告知自己要重启呢？</li>\n</ul>\n<p>首先，在用户发送请求之前，a 进程需要向 Nginx 注册自己的地址和端口，以便 Nginx 能够将请求转发到自己。这可以通过向一个共享的配置文件中写入自己的地址和端口来实现。例如，在 Node.js 中可以使用共享内存来实现：</p>\n<pre><code>const cluster = require('cluster');\nconst fs = require('fs');\n\nif (cluster.isMaster) {\n // 创建共享内存\n const fd = fs.openSync('worker-info.txt', 'w+');\n\n for (let i = 0; i &lt; numCPUs; i++) {\n   const worker = cluster.fork();\n\n   // 监听worker上报自己的地址和端口\n   worker.on('message', (message) =&gt; {\n     if (message.type === 'REGISTER') {\n       // 写入共享文件中\n       fs.write(fd, `${message.pid} ${message.address} ${message.port}\\n`);\n     }\n   });\n }\n} else {\n const express = require('express');\n const app = express();\n\n // 启动HTTP服务器并上报自己的地址和端口\n const server = app.listen(0, () =&gt; {\n   const message = {\n     type: 'REGISTER',\n     pid: process.pid,\n     address: server.address().address,\n     port: server.address().port\n   };\n   process.send(message);\n });\n\n // 处理HTTP请求逻辑\n app.get('/', (req, res) =&gt; {\n   // TODO: 处理请求\n });\n}\n</code></pre>\n<p>在上面的例子中，每个进程都会从共享文件中读取其他进程的地址和端口，以便进行Nginx负载均衡。</p>\n<p>接下来，在更新a进程之前，可以将a进程从Nginx负载均衡的后端服务器列表中移除，并发送一个信号让a进程重启。例如，在Node.js中可以使用process.kill方法发送信号：</p>\n<pre><code>const fs = require('fs');\n\n// 读取共享文件中的地址和端口\nconst workers = {};\nfs.readFileSync('worker-info.txt', 'utf8').split('\\n').forEach((line) =&gt; {\n  const [pid, address, port] = line.trim().split(' ');\n  if (pid &amp;&amp; address &amp;&amp; port) {\n    workers[pid] = { address, port };\n  }\n});\n\n// 从Nginx负载均衡列表中移除当前进程\ndelete workers[process.pid];\nfs.writeFileSync('worker-info.txt', Object.values(workers).map((w) =&gt; `${w.address} ${w.port}`).join('\\n'));\n\n// 发送重启信号\nprocess.kill(process.pid, 'SIGTERM');\n</code></pre>\n<p>在这个例子中，首先读取共享文件中的所有进程地址和端口，然后从中移除当前进程的地址和端</p>\n")),p=[t,n("puppeteer",o("puppeteer","网页截图&PDF生成","/notes/nodejs/puppeteer","<h1>Puppeteer 谷歌无头浏览器使用</h1>\n<h2>简介</h2>\n<p>Puppeteer 是一个 Node.js 库，提供了一组基于 Chrome DevTools 协议的高级 API，可用于通过编程方式控制 Chrome 浏览器或 Chromium 浏览器的操作。</p>\n<p>Puppeteer 可以做什么？</p>\n<ol>\n<li>爬虫：可以使用 Puppeteer 爬取网站，获取数据，并解析结果。</li>\n<li>自动化测试：可以使用 Puppeteer 进行 UI 自动化测试，自动执行登录、下单等页面操作，并对这些操作进行测试。</li>\n<li>性能分析：可以使用 Puppeteer 访问页面并生成跟踪数据，进而分析页面性能，如加载时间等指标。</li>\n<li>截图和生成 PDF：可以使用 Puppeteer 对页面进行截图，生成 PDF 等操作。【该功能比较好用】</li>\n<li>模拟用户行为：可以使用 Puppeteer 模拟鼠标和键盘操作，实现自动化。\n总之，Puppeteer 可以模拟用户在浏览器中的所有行为，并提供了丰富的 API，方便开发人员进行编程式操作。</li>\n</ol>\n<h2>Puppeteer 对比 canvas 的优势？</h2>\n<p>在国内软件应用中，海报等形式的图片分享是流量裂变的重要手段之一。对于前端而言，利用 Canvas 绘制并通过 HTMLCanvasElement.toDataURL()等 API 最终获得图片数据是一种可选方法。但是这种方法存在很多令人不能容忍的缺点，比如：</p>\n<ul>\n<li>绘制在其中的图片需要遵循浏览器同源策略，否则生成图片数据时候会失败。</li>\n<li>绘制复杂的大图时，会耗费较多客户端性能。</li>\n<li>实现简单的布局效果，需要繁琐的 API，并且不一能和 Web 端展示效果一样。</li>\n</ul>\n<h3>demo</h3>\n<pre><code>1. mkdir project\n2. cd project\n3. npm init -y\n4. npm i koa puppeteer koa-router --save\n5. mkdir public\n6. mkdir src\n7. cd src\n8. echo  &gt; index.js\n</code></pre>\n<p>此时文件目录</p>\n<pre><code>project\n- public\n- src\n-- index.js\n</code></pre>\n<p>编辑index.js文件</p>\n<pre><code>const Koa = require(&quot;koa&quot;);\nconst app = new Koa();\nconst port = 5000;\nconst Router = require(&quot;koa-router&quot;);\nconst puppeteer = require(&quot;puppeteer&quot;);\nconst router = new Router();\n\n// 截取某个dom页面\nasync function demo1() {\n  // 页面是可以注入数据\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n  // 去京东的官网截取某个dom节点的图\n  await page.goto(&quot;https://www.jd.com&quot;, {\n    waitUntil: [&quot;domcontentloaded&quot;, &quot;networkidle2&quot;, &quot;load&quot;],\n  });\n  const domSelector = &quot;J_promotional-top&quot;;\n  const dom = await page.$(`#${domSelector}`);\n  const domInfos = await dom.boundingBox();\n  const options = {\n    clip: {\n      x: domInfos.x,\n      y: domInfos.y,\n      width: domInfos.width,\n      height: domInfos.height,\n    },\n    path: `./public/example-${Date.now()}-${domSelector}.png`,\n  };\n  await page.screenshot(options);\n  await browser.close();\n}\n\n// 截取整个页面\nasync function demo2() {\n  // 页面是可以注入数据\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n  await page.goto(&quot;https://www.jd.com&quot;, {\n    waitUntil: [&quot;domcontentloaded&quot;, &quot;networkidle2&quot;, &quot;load&quot;],\n  });\n  await page.screenshot({\n    path: `./public/example-${Date.now()}-fullpage.png`,\n    fullPage: true,\n  });\n  await browser.close();\n}\n\n// 页面转成pdf\nasync function demo3() {\n  // 页面是可以注入数据\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n  await page.goto(&quot;https://www.zhihu.com/signin?next=%2F&quot;, {\n    waitUntil: [&quot;domcontentloaded&quot;, &quot;networkidle2&quot;, &quot;load&quot;],\n  });\n\n  await page.pdf({ path: `./public/example-${Date.now()}.pdf` });\n  await browser.close();\n}\n\n// 访问这个服务器地址，去执行某个操作，截图生成pdf等\nrouter.get(&quot;/&quot;, async (ctx) =&gt; {\n  await demo3();\n  ctx.body = &quot;&lt;h1&gt;done&lt;/h1&gt;&quot;;\n});\n\n// 注册路由中间件\napp.use(router.routes());\napp.use(router.allowedMethods({}));\napp.listen(port, onStartAfterCb);\napp.on(&quot;error&quot;, onError);\n\n// 记录日志或发送告警。\nfunction onError(error, ctx) {\n  console.error(&quot;koa error:&quot;, error, ctx);\n  // 执行一些处理逻辑\n}\n\n// 应用启动后做的一些操作\nfunction onStartAfterCb() {\n  console.log(`app start at: http://0.0.0.0:${port}`);\n}\n\n</code></pre>\n<p>然后我们就可以测试功能，打开命令行win+r 输入cmd,因为我们对外抛出了一个接口，此时我们只需要去调用这个接口便可以执行相应的操作</p>\n<p>在命令行中输入如下命令</p>\n<pre><code>curl -X GET `yourIp:${port}`\n</code></pre>\n<p>便可在public文件夹看到相应的文件，至此一个简单的demo完成了</p>\n")),r];n({page:p,default:p}),n("__module",o("intro","node-js","/notes/nodejs/intro",e,p))}}}));
